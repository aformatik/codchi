[{"data":1,"prerenderedAt":366},["ShallowReactive",2],{"search-api":3},[4,11,21,31,38,45,54,61,73,82,89,96,103,111,118,125,133,140,147,154,161,168,176,183,190,197,204,212,219,226,235,242,250,260,268,277,285,291,300,307,313,321,337,348,360],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Reproducible and Reliable Development Environments",[],"     Reproducible and Reliable Development Environments   Codchi is a tool that manages your project's development environment in a reproducible and easy-to-use way. Setting up a development environment should be as easy as a   git clone !   Codchi is currently in beta and still under active development and testing. Please expect potential bugs and incomplete features. We welcome feedback and contributions to help improve stability and functionality!                                    Codchi's features      Reproducible and Reliable   Codchi builds on the excellent Nix package manager to install, update, and roll back your project's development environment. This means bit-for-bit reproducible environments on any machine.    Declarative   Code Machines are defined in code and checked into your repository, allowing you to check out the correct environment at every commit of your project.    Built on Standards   We didn't reinvent the wheel - every NixOS module is a valid Code Machine. Also, every Code Machine is a valid NixOS module, so you're not locked into Codchi.    Easy to install   Installing a Code Machine is as easy as copying and pasting the link to the project repository into Codchi and waiting a few minutes for the installation process to complete.    Easy to use   Once installed, shortcuts to graphical programs will appear in your start menu, or you can access a shell containing all available tools.    Native and Cross Platform   Native Looks and Performance on Windows 10, Windows 11 and Linux. Every Code Machine runs the same on any device.",{"id":12,"path":13,"dir":14,"title":15,"description":16,"keywords":17,"body":20},"content:1.introduction:0.what-is-codchi.md","/introduction/what-is-codchi","introduction","What is Codchi?","Codchi is a tool that manages your project's development environment. It uses the excellent Nix package manager to install, update, and roll back your project's development environment in a reproducible way - on any Windows or Linux machine. The development environments are defined in code and checked into your repository, allowing you to",[18,19],"How it Works","When should I (not) use Codchi?","  What is Codchi?  Codchi is a tool that manages your project's development environment. It uses the excellent   Nix package manager  to install, update, and roll back your project's development environment in a reproducible way - on any Windows or Linux machine. The development environments are defined in code and checked into your repository, allowing you to   share your environment   reproducibly  with your colleagues,  automate the installation and setup of the development environment,  check out a working development environment at every commit of your project.  Codchi uses virtualisation technologies like KVM and Hyper-V to provide an isolated environment while maintaining near-native performance and user experience of the tools (command-line as well as graphical) you're running. This means that Codchi can provide several versions of the development environment for the same project at the same time without polluting your host system.  Codchi's goal is to minimize the amount of thoughts you put into your development environment. Let's say the project you're working on is a Java web app that needs a JDK, an IDE like   IntelliJ IDEA , a web server and a database. With Codchi, the installation is as simple as providing the Codchi command-line interface with the link to the repository and waiting for a few minutes for the installation to finish. Now every time you launch the Java code machine - just in a terminal or via the automatically created shortcut directly into IntelliJ - the server and database are started and tools like the JDK are available. If at some point the tools in your development environment are updated or new ones are added, Codchi will keep track of the changes and provide the up-to-date environment. The reverse is also true: Reverting to an enviroment for any old commit in your project's history is as simple as checking out that commit.  How it Works  Code machines are to Codchi what containers are to Docker. A code machine is comprised of a number of   modules  (usually just one). A module is a plain NixOS Module inside a git repository which defines the development environment of that repository. Since it's just code, it is versioned just as the rest of the repository, which gives Codchi the ability to create a development environment for every commit of that project.    After configuration a code machine is built into a NixOS system inside a container. On Windows this is a WSL instance, on Linux a LXD container. The Codchi binary itself runs on the host system in order to provide features like passthrough of graphics and sound or start menu shortcuts for applications inside code machines. Also Codchi provides niceties like store-sharing between machines. In essence Codchi is a cross-platform driver for NixOS systems that takes care of the tedious hardware and system integration, so that you only have to think about the actual programs and services you want to run.  When should I (not) use Codchi?  It might seem that other tools like   devenv.sh  or   flox  already provide the exact same functionality as Codchi, but there are some important differences:    Nix Shell vs. NixOS : Tools like devenv.sh and flox provide the development environment in a (bash) shell without completely isolating them from the host. This is simpler and more performant than NixOS containers, but doesn't provide proper isolation which many, especially more complex enterprise development enviroments need.   User Experience : Both tools assume a Unix-like operating system with Nix already installed. Also often they assume an IDE like VSCode is already installed on the host system. Codchi on the other hand provides a \"single click installation\" which aims to be as user friendly as possible. Everything from the compiler and services to the IDE is provided when installing a code machine. Also since Codchi controls the virtualisation technology it can provide features like secret management and GPU computing by interfacing with the host OS.   Configuration : Codchi uses NixOS options while other tools have their own, much more limited option set. This means that in addition to Codchi's own options you can use   more than 10000 NixOS Options !  On the other hand, if it is a relatively simple development environment (e.g. projects that get by with only a LSP server and a few services) and it can be assumed that all developers have access to a Unix shell, simpler approaches such as simple Nix shells, devenv.sh or flox are more suitable.\nFurthermore, you can use both Codchi and devenv tools like devenv.sh and flox where they're best at: Codchi provides a consistent environment and proper host integration across Windows and Linux and devenv.sh or flox provide the development environment itself which can also be used outside of Codchi.",{"id":22,"path":23,"dir":14,"title":24,"description":7,"keywords":25,"body":30},"content:1.introduction:1.installation.md","/introduction/installation","Installation",[26,27,28,29],"Windows 10 & 11","Linux","NixOS","MacOS","  Installation  Windows 10 & 11  Prerequisites  On Windows, Codchi uses the   Windows Subsystem for Linux , which is available for free from Microsoft.   Installing WSL enables Microsoft's Hyper-V Hypervisor, which might cause issues with older virtualisation technologies like VMware. Don't worry, you can   disable or re-enable Hyper-V  at any time.  Make sure that WSL2 is installed and up to date. In a terminal,   wsl.exe --version  should output something like the following, where WSL-Version\nshould be   2.0.14  or greater:     WSL  -  Version:   2.0  .  14.0\n   Kernelversion:   5.15  .  133.1  -  1\n   WSLg  -  Version:   1.0  .  59\n   MSRDC  -  Version:   1.2  .  4677\n   Direct3D  -  Version:   1.611  .  1  -  81528511\n   DXCore  -  Version:   10.0  .  25131.1002  -  220531  -  1700.  rs  -  onecore  -  base2  -  hyp\n   Windows  -  Version:   10.0  .  22631.3296\n  If WSL is not installed:     wsl.exe   --  install   --  no  -  distribution   --  web  -  download\n  If WSL is installed but too old:     wsl.exe   --  update   --  web  -  download\n  Now recheck   wsl.exe --version .  A system restart is recommended after installing or updating WSL to ensure all changes take effect.  Install Codchi  Download, open and install the latest\n  codchi.msix .   MSIX  or\n  AppX  is the packaging format for Windows Apps and should work out of the box.\nWindows even handles subsequent updates of Codchi automatically, but you can\ndownload and install a newer codchi.msix at any time.  Shell Completions  On some Windows Systems running PowerShell scripts is considered a security vulnerability and often completely disabled. Therefore Codchi doesn't try to automatically run PowerShell scripts and you have to manually add the following to the end of your PowerShell configuration (find it by running   $PROFILE  in PowerShell):     Invoke-Expression   (  &   codchi completion powershell   |   Out-String  )\n  Further Recommendations   For better tab complete and history search:\n     # Shows navigable menu of all options when hitting tab\n   Set-PSReadlineKeyHandler   -  Key Tab   -  Function MenuComplete\n   \n   # Autocompletion for arrow keys (when something was already typed)\n   Set-PSReadlineKeyHandler   -  Key UpArrow   -  Function HistorySearchBackward\n   Set-PSReadlineKeyHandler   -  Key DownArrow   -  Function HistorySearchForward\n  Install   Starship.rs  for a better prompt  Linux  Prerequisites  On Linux Codchi uses   LXD  for virtualisation.\nFollow the official   installation instructions \nuntil   lxd init .  Install Codchi  Currently, Codchi is only packaged with   Nix  on Linux.  Install Nix (uses the   Determinate Nix Installer ):     # with SystemD:\n   curl   --proto   '=https'   --tlsv1.2   -sSf   -L   https://install.determinate.systems/nix   |   sh   -s   --   install\n   # without SystemD:\n   curl   --proto   '=https'   --tlsv1.2   -sSf   -L   https://install.determinate.systems/nix   |   sh   -s   --   install   --init   none\n  Now install codchi (omit   --accept-flake-config  to not use Codchi's binary cache):     nix   --accept-flake-config   profile   install   github:aformatik/codchi/latest\n  Shell Completions  When installed via Nix, shell completions should automatically work inside bash, zsh and fish. There are also   completions  available for the following shells which must be installed manually by the user:   carapace  elvish  fig  nushell  For example for elvish:     eval   (codchi   completion   elvish   |   slurp  )\n  NixOS  Prerequisites  Flakes need to be activated.  Install LXD and add codchi's binary cache (optional but faster):     virtualisation  .  lxd  .  enable   =   true  ;\n   virtualisation  .  lxc  .  lxcfs  .  enable   =   true  ;\n   virtualisation  .  lxd  .  recommendedSysctlSettings   =   true  ;\n   \n   # Allow your user to use LXD\n   users  .  users  .\u003C  your   user  >.  extraGroups   =   [   \"lxd\"   ]  ;\n   \n   # optional but recommended:\n   nix  .  settings   =   {\n     extra-substituters   =   [   \"https://codchi.cachix.org\"   ];\n     trusted-public-keys   =   [   \"codchi.cachix.org-1:dVwdzogJgZO2x8kPKW02HNt2dpd/P/z46pY465MkokY=\"   ];\n   }  ;\n   \n   # If you use a local DNS server. See https://github.com/NixOS/nixpkgs/issues/263359\n   networking  .  firewall  .  interfaces  .  lxdbr0  .  allowedTCPPorts   =   [   53   ]  ;\n   networking  .  firewall  .  interfaces  .  lxdbr0  .  allowedUDPPorts   =   [   53   67   ]  ;\n  Now,   nixos-rebuild . Then run   lxd init  manually.  Shell Completions  Shell completions should automatically work inside bash, zsh and fish, provided that shell completion is enabled:     {\n       programs  .  bash  .  enableBashCompletion   =   true  ;\n       programs  .  zsh  .  enableBashCompletion   =   true  ;\n       programs  .  fish  .  vendor  .  completions  .  enable   =   true  ;\n   }\n  There are also   completions  available for the following shells which must be installed manually by the user:   carapace  elvish  fig  nushell  For example for nushell (via home-manager):     { pkgs  ,   inputs  ,   ...   }: {\n       programs  .  nushell  .  extraConfig   =   ''\n           source   ${  pkgs  .  runCommand   \"codchi-nushell-complete\"   {}   ''\n             ${  inputs  .  codchi  .  packages  .  ${  pkgs  .  system  }  .  default  }  /bin/codchi complete nushell > $out\n           ''  }\n       ''  ;\n   }\n  Install Codchi  In your flake.nix:     inputs  .  codchi  .  url   =   \"github:aformatik/codchi/latest\"  ;\n   inputs  .  codchi  .  nixpkgs  .  follows   =   \"nixpkgs\"  ;\n   \n   outputs   =   inputs@{   ...   }: {\n       # Pass inputs to your NixOS configuration (e.g. via extraArgs)\n   };\n  In your NixOS configuration:     { inputs  ,   ...   }: {\n     environment  .  systemPackages   =   [   inputs  .  codchi  .  packages  .  x86_64-linux  .  default   ];\n   }\n  MacOS   Currently not implemented. Possible Drivers are   https://orbstack.dev/  (proprietary) and   https://lima-vm.io/  (open source, limited support for the newer faster virtualisation on Macs)  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":32,"path":33,"dir":14,"title":34,"description":35,"keywords":36,"body":37},"content:1.introduction:2.first-code-machine.md","/introduction/first-code-machine","Your first Code Machine","To create a machine for a given project, simply copy the link of its git repository (currently only http(s)).",[],"  Your first Code Machine  To create a machine for a given project, simply copy the link of its git repository (currently only http(s)).  Open a terminal and create the machine with a   MACHINE_NAME  of your choice. If you're not sure how to answer a question, just choose the default answer:     codchi   init   MACHINE_NAME   https://github.com/link/to/repo\n   If you don't have a repository with a Codchi module, you can try this machine (OpenJDK, Maven and IntelliJ IDEA):     codchi   init   MACHINE_NAME   https://github.com/aformatik/codchi   nixosModules.jvm\n  Thats it! After a few minutes your machine should be installed and you can now open a shell inside the machine or directly run a program:     codchi   exec   MACHINE_NAME\n   # If IntelliJ is installed\n   codchi   exec   MACHINE_NAME   idea-community\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":39,"path":40,"dir":14,"title":41,"description":42,"keywords":43,"body":44},"content:1.introduction:3.config.md","/introduction/config","Configuration","Codchi itself can be configured via the system tray icon or by editing:",[],"  Configuration  Codchi itself can be configured via the system tray icon or by editing:    Windows:    %APPDATA%\\codchi\\config.toml  (  %APPDATA%  is most likely   C:\\Users\\NAME\\AppData\\Roaming )   Linux:    $XDG_CONFIG_HOME/codchi/config.toml  (  $XDG_CONFIG_HOME  is most likely   ~/.config )      # Just leave it empty to use the defaults. This is sufficient for most users\n     data_dir =   'C:\\Users\\me\\AppData\\Local\\codchi'\n   \n   enable_wsl_vpnkit =   false  ;\n   tray.autostart =   true\n   \n   [  vcxsrv  ]\n   enable =   false\n   tray_icon =   false\n     data_dir =   \"/home/me/.local/share/codchi\"\n   tray.autostart =   true\n      Key   Type   Default   Description     data_dir   string   %LOCALAPPDATA%\\codchi ,   $XDG_DATA_HOME/codchi  The path where codchi stores data files from code machines    tray.autostart   bool   true  Whether to automatically start the Codchi system tray icon    vcxsrv.enable  (Windows only)   bool   false  Whether to use   VcXsrv , a X-Server for Windows, instead of Windows' own RDP solution. VcXsrv mostly has a better user experience and better performance but still has some bugs. Currently Codchi is shipped without VcXsrv due to security concerns, but it can be installed manually. It must be installed to   $env:ProgramData\\VcXsrv .    vcxsrv.tray_icon  (Windows only)   bool   false  Whether to show VcXsrv's system tray icon    enable_wsl_vpnkit  (Windows only)   bool   false  Whether to enable   wsl-vpnkit , which enables internet access in WSL inside some company VPNs  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":46,"path":47,"dir":14,"title":48,"description":7,"keywords":49,"body":53},"content:1.introduction:4.troubleshooting.md","/introduction/troubleshooting","Troubleshooting",[50,51,52],"Timezone is wrong","Linux: Graphical Applications don't Work","WSL: Failed initializing Driver","  Troubleshooting  Timezone is wrong  By default, both WSL and LXD use UTC as the default timezone. To set another timezone, use    time.timeZone :     # configuration.nix\n   {\n       time  .  timeZone   =   \"Europe/Berlin\"  ;\n   }\n  Linux: Graphical Applications don't Work  When opening graphical applications inside a code machine you might encounter an error like this:   Error: Can't open display\n  Although Codchi does its best to make the X-Server available inside a code machine (which is a LXD container on Linux), there can be issues with authentication against the host's X-Server. Codchi tries to set the Xauthority cookie. If this fails, you can try to allow all local connections to the X-Server (although this may be somewhat insecure):   xhost +local:\n  WSL: Failed initializing Driver  Currently, the   codchistore  file system may get corrupted, rendering Codchi unusable. The error looks something like this:   Failed initializing Driver.: LinuxCommandBuilder { driver: LinuxCommandDriver { instance_name: \"codchistore\" }, program: Run { program: \"/sbin/init\", args: [] }, user: None, cwd: Some(LinuxPath(\"/\")), cmd: \"wsl.exe\" \"-d\" \"codchistore\" \"--cd\" \"/\" \"--\" \"run\" \"/sbin/init\" } failed with exit status ExitStatus(ExitStatus(1)). Stderr:\n\u003C3>WSL (9) ERROR: CreateProcessParseCommon:809: getpwuid(0) failed 2\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Users\\Dev\\AppData\\Roaming\\codchi\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Users\\Dev\\AppData\\Local\\codchi\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\iCLS\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\iCLS\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\WINDOWS\\system32\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\WINDOWS\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\WINDOWS\\System32\\Wbem\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\WINDOWS\\System32\\OpenSSH\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\DAL\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\DAL\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files (x86)\\Intel\\Intel(R) Management Engine Components\\IPT\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Intel\\Intel(R) Management Engine Components\\IPT\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Intel\\WiFi\\bin\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Common Files\\Intel\\WirelessCommon\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\ProgramData\\chocolatey\\bin\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\dotnet\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\starship\\bin\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\PowerShell\\7\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Tailscale\\\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Docker\\Docker\\resources\\bin\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Program Files\\Neovim\\bin\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Users\\Dev\\AppData\\Local\\Microsoft\\WindowsApps\n\u003C3>WSL (9) ERROR: UtilTranslatePathList:2852: Failed to translate C:\\Users\\Dev\\AppData\\Local\\Programs\\Git\\cmd\n\u003C3>WSL (9) ERROR: CreateProcessCommon:392: getpwuid(0) failed 2\n\u003C3>WSL (9) ERROR: CreateProcessCommon:559: execvpe(/bin/sh) failed: No such file or directory\n  To resolve this, run the command   codchi store recover , after which Codchi should work again.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":55,"path":56,"dir":14,"title":57,"description":58,"keywords":59,"body":60},"content:1.introduction:5.vm.md","/introduction/vm","Migrating away from Codchi","One of our main principles is not to lock the user into Codchi. Code machines consist of three parts:",[],"  Migrating away from Codchi  One of our main principles is not to lock the user into Codchi. Code machines consist of three parts:   Configuration (NixOS modules)  File system state  The Codchi driver  To migrate away from Codchi just use your existing code machine configuration (1), copy your files (2) and bring your own hardware driver / configuration (3). For development environments this could be a VM.\nThis is how it works in practise:    Install NixOS  in a virtual machine. The easiest way is to use a graphical ISO image.\nUse   codchi  as your user name.  Export your code machine with   codchi tar \u003CMACHINE_NAME> my-files.tar  Copy   my-files.tar  to the VM and extract it:     cd   /\n   sudo   su\n   tar   --no-overwrite-dir   -xf   /path/to/my-files.tar\n   chmod   755   /\n  Add the VM configuration to your code machine flake:     sudo   nano   /etc/nixos/flake.nix\n     {\n     inputs   =   {\n       codchi_driver  .  url   =   \"github:aformatik/codchi/master\"  ;\n       \"codchi-secrets\"  .  url   =   \"github:aformatik/codchi?host=github.com\"  ;\n     };\n     outputs   =   inputs: {\n       nixosConfigurations  .  nixos   =   inputs  .  \"codchi-secrets\"  .  inputs  .  nixpkgs  .  lib  .  nixosSystem   {\n         system   =   \"x86_64-linux\"  ;\n         modules   =   [\n           { \n                _module  .  args  .  inputs  .  nixpkgs   =   inputs  .  \"codchi-secrets\"  .  inputs  .  nixpkgs  ; \n                codchi  .  driver  .  name   =   \"none\"  ;\n           }\n           inputs  .  codchi_driver  .  nixosModules  .  default\n           inputs  .  \"codchi-secrets\"  .  nixosModules  .  secrets\n           ./configuration.nix   # \u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C\u003C add this line\n         ];\n       };\n     };\n   }\n  Now build your system:     sudo   nixos-rebuild   switch\n   codchi tar  creates a flake that uses exactly the same modules as the code machine, which means your VM can stay up to date with your code machine when using remote modules. Also Codchi's [custom NixOS options](../3.config/99.Codchi specific NixOS Options.md) will continue to work (without the Codchi host integration, like the GPU). Your secrets and previous machine name are stored in   /etc/codchi-env .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":62,"path":63,"dir":64,"title":65,"description":66,"keywords":67,"body":72},"content:2.usage:clone.md","/usage/clone","usage","codchi clone","Clone a project and initialize its code machine using the cloned module.",[68,69,70,71],"Synopsis","Description","Options","Examples","  codchi clone  Clone a project and initialize its code machine using the cloned module.  Synopsis   codchi clone     --depth     --single-branch   --recurse-submodules     --shallow-submodules   -d |  --dir     -r |  --keep-remote   -n |  --dont-run-init     -y |  --dont-prompt   -N |  --no-build     -p |  --use-nixpkgs   -a |  --auth     -b |  --branch     --tag   -c |  --commit     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  MACHINE_NAME > \u003C  URL >    MODULE_PATHS  Description  This command unifies the following commands:   codchi init \u003CMACHINE_NAME> \u003CURL>\ncodchi exec \u003CMACHINE_NAME> git clone \u003CURL> \u003CTARGET_DIR>\ncodchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --url \u003CTARGET_DIR>\n  See the documentation of each command for more information.  Options    --depth =  DEPTH  Same as   git clone --depth   --single-branch  Same as   git clone --single-branch   --recurse-submodules  Same as   git clone --recurse-submodules   --shallow-submodules  Same as   git clone --shallow-submodules   -d ,   --dir =  DIR  The target directory, relative to   $HOME , for the git repo. If\nleft empty this will chosen by git   -r ,   --keep-remote  Dont switch to the local codchi module   -n ,   --dont-run-init  Do not execute the init script automatically (NixOS option\n  codchi.initScript )   -y ,   --dont-prompt  Dont prompt for confirmation and accept all of Codchis defaults.\nUsefull for using Codchi in scripts   -N ,   --no-build  Dont automatically build this machine after this command completes   -p ,   --use-nixpkgs =  USE_NIXPKGS  Whether to use Nixpkgs from the   local  Codchi installation or\nthe   remote  URL. See the \"Which nixpkgs should I use?\"\nsection of   codchi init  for more details.  By default Codchi will use   remote  if    defines a\nnixpkgs input in its flake. Otherwise it will use the   local \nnixpkgs.   *possible values: *local, remote   -a ,   --auth =  AUTH  Authorisation string for private repositories. Generally, the syntax\nis   \u003Cuser>:\u003Ctoken>  or just   \u003Ctoken> .  GitHub for example has something like\n  ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  whereas GitLab uses\n  oauth2:glpat-xxxxxxxxxxxxxxxxxxxx .   -b ,   --branch =  BRANCH  The git branch to use for the code machine module   --tag =  TAG  The git tag to use for the code machine module   -c ,   --commit =  COMMIT  The git commit to use for the code machine module   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  MACHINE_NAME >  Name of the code machine  \u003C  URL >  HTTP(S) URL to the git repository    MODULE_PATHS  A list of flake paths to the Codchi modules you whish to add.\nCurrently supported: codchiModules.   or\nnixosModules.  . If not sure which modules are available,\nleave this empty. Codchi will prompt you with a list of possible\noptions.  With   --dont-prompt  this argument is required.  Examples  Install and clone the Codchi repo / machine:   codchi clone \u003CMACHINE_NAME> https://github.com/aformatik/codchi nixosModules.codchi\ncodchi exec \u003CMACHINE_NAME>\ncd codchi/codchi\ncargo build\n",{"id":74,"path":75,"dir":64,"title":76,"description":77,"keywords":78,"body":81},"content:2.usage:codchi.md","/usage/codchi","codchi","Codchi is a tool that manages your project's development environment in\na reproducible and easy-to-use way. Setting up a development environment\nshould be as easy as a git clone!",[68,79,70,71,80],"Subcommands","Version","  codchi  Codchi is a tool that manages your project's development environment in\na reproducible and easy-to-use way. Setting up a development environment\nshould be as easy as a   git clone !    What is Codchi?   Configuring Codchi   Codchi Module Configuration  The default subcommand is   codchi status .  Synopsis   codchi     -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help     -V |  --version   subcommands  Subcommands   codchi-status(1)  List installed code machines and their status  codchi-init(1)  Initialize a new code machine  codchi-clone(1)  Clone a project and initialize its code machine using the cloned\nmodule.  codchi-secrets(1)  Manage secrets of code machines.  codchi-module(1)  Manage modules of code machines.  codchi-rebuild(1)  Apply changes to a code machine. By default this also fetches\nupdates for each module.  codchi-exec(1)  Execute a command inside a code machine. The code machine will be\nstarted if not already running.  codchi-delete(1)  Delete a code machine with all associated files.  codchi-duplicate(1)  Duplicate a code machine.  codchi-gc(1)  Perform garbage collection of old nix store paths.  codchi-completion(1)  Generate shell completions.  codchi-tar(1)  Export the file system of a code machine including NixOS\nconfiguration and codchi secrets.  codchi-store(1)  Utilities for interacting with the   codchistore  container.  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)   -V ,   --version  Print version  Examples  Create a code machine with a Java devenv and launch the IntelliJ GUI:   codchi init java-demo https://github.com/aformatik/codchi nixosModules.jvm\ncodchi exec java-demo idea-community\n  Create an empty code machine (e.g. to use   flake.nix  or   devenv.sh ):   codchi init devenv-sh\ncodchi exec devenv-sh\nnix run nixpkgs#nushell\n  Remove the code machines above and collect their garbage:   codchi delete java-demo\n> Delete 'java-demo'? Yes\ncodchi delete devenv-sh\n> Delete 'devenv-sh'? Yes\ncodchi gc\n  Version  v0.3.1",{"id":83,"path":84,"dir":64,"title":85,"description":86,"keywords":87,"body":88},"content:2.usage:completion.md","/usage/completion","codchi completion","Generate shell completions.",[68,69,70],"  codchi completion  Generate shell completions.  Synopsis   codchi completion     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  SHELL >  Description  See the following docs on how to register the completions with your\nshell:    Windows   Linux   NixOS  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  SHELL >  The shell to generate the completions for   *possible values: *bash, carapace, elvish, fig, fish, nushell,\npowershell, zsh",{"id":90,"path":91,"dir":64,"title":92,"description":93,"keywords":94,"body":95},"content:2.usage:delete.md","/usage/delete","codchi delete","Delete a code machine with all associated files.",[68,69,70],"  codchi delete  Delete a code machine with all associated files.  Synopsis   codchi delete     --i-am-really-sure   -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help  \u003C  NAME >  Description  WARNING: This will irrevocably delete all files belonging to the code machine!  Options    --i-am-really-sure  Dont prompt for confirmation and delete this machine immediately   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  NAME >  Name of the code machine",{"id":97,"path":98,"dir":64,"title":99,"description":100,"keywords":101,"body":102},"content:2.usage:duplicate.md","/usage/duplicate","codchi duplicate","Duplicate a code machine.",[68,70],"  codchi duplicate  Duplicate a code machine.  Synopsis   codchi duplicate     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  SOURCE_NAME > \u003C  TARGET_NAME >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  SOURCE_NAME >  Name of the code machine to duplicate  \u003C  TARGET_NAME >  Name of the new code machine",{"id":104,"path":105,"dir":64,"title":106,"description":107,"keywords":108,"body":110},"content:2.usage:exec.md","/usage/exec","codchi exec","Execute a command inside a code machine. The code machine will be\nstarted if not already running.",[68,70,109,71],"Extra","  codchi exec  Execute a command inside a code machine. The code machine will be\nstarted if not already running.  Synopsis   codchi exec     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  NAME >    CMD  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  NAME >  Name of the code machine    CMD  Command with arguments to run. Leave empty to open a shell  Extra  Running graphical programs  Programs which provide shortcuts (usually graphical programs) are added\nto your host's system menu as shortcuts and can be started by clicking\nthem.  Examples  Open a shell inside :   codchi exec \u003CMACHINE_NAME>\n  Run   PROGRAM [ARGS...]  inside :   codchi exec \u003CMACHINE_NAME> PROGRAM [ARGS...]\n  For example,   uname -a :   codchi exec \u003CMACHINE_NAME> uname -a\n  If some options conflict with Codchi's options, you can escape them with\n  -- :   codchi exec \u003CMACHINE_NAME> -- PROGRAM [ARGS...]\n",{"id":112,"path":113,"dir":64,"title":114,"description":115,"keywords":116,"body":117},"content:2.usage:gc.md","/usage/gc","codchi gc","Perform garbage collection of old nix store paths.",[68,69,70,109,71],"  codchi gc  Perform garbage collection of old nix store paths.  Synopsis   codchi gc     -d |  --delete-old     -a |  --all   -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help     MACHINES  Description  All programs and system files reside in the append-only Nix Store. Over\ntime the store will grow in size noticably, because everytime a\n  codchi rebuild  is run, new files get added to the store. Therefore you\nmight want to perform a garbage collection from time to time.  By default, garbage collection will   not  delete old machine\ngenerations in order to allow instantaneous rollbacks. The drawback is\nthat the store paths refered to in the old generations never get freed.\nTo also delete old generations, use   --delete-old  with an optional\nminimum age (in days). Note that only explicitly listed machines\n(  MACHINES... ) will be processed. To process all installed machines,\nuse   --all .  WARNING  In Codchi, the Nix Store is shared across all code machines, which means\nthat the garbage collector also shares a directory of roots (\"gcroots\")\nthat should be preserved, such as the current system configuration of\neach code machine. On a vanilla NixOS system, local gcroots (such as\nthose created by   nix build  or direnv) are automatically registered and\nprotected from garbage collection. However, this doesn't work in Codchi\nat the moment, because the garbage collector has a different view on the\nfile system of each code machine. As a result, the local gcroots of\nindividual machines become invalid. For example, a gcroot pointing to\n  /home/codchi/result  on machine   foo  is invalid from the perspective\nof Codchi, as the correct path would be   /data/machine/foo/result .  This isn't a huge issue, as the deleted store paths can be redownloaded\nor rebuilt.  Options    -d ,   --delete-old =  AGE  Delete old machine generations. AGE is the minimum age in days to be\ndeleted   default: 0   -a ,   --all  Process all machines. Requires   --delete-old   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)    MACHINES  Machines to be processed. Requires   --delete-old  Extra  Large WSL Distributions  On Windows, the store is inside the WSL distribution `codchistore'. By\ndefault WSL distributions only grow in size, once used disk space is not\nautomatically reclaimed. Codchi will try to set the distribution to\nsparse mode which should automatically free unused space. If this\ndoesn't work, you can do it automatically with   wsl.exe --manage codchistore --set-sparse true\n  Beware that WSL needs to be shut down for this which will close all\nrunning Linux programs.  If sparse mode somehow doesn't work correctly, you can manually shrink a\nWSL distribution like this:   wsl.exe --terminate codchistore\ndiskpart # this will need admin rights\nselect vdisk file=\"C:UsersYOUR_USERAppDataLocalcodchistoreext4.vhdx\"\ncompact vdisk\nexit\n  Examples  Delete generations older than one month of and :   codchi gc --delete-old 30 \u003CMACHINE_1> \u003CMACHINE_2>\n  Delete all but the current generation from each installed machine:   codchi gc --all --delete-old\n",{"id":119,"path":120,"dir":64,"title":121,"description":122,"keywords":123,"body":124},"content:2.usage:init.md","/usage/init","codchi init","Initialize a new code machine",[68,69,70,109,71],"  codchi init  Initialize a new code machine  Synopsis   codchi init     -n |  --dont-run-init   -y |  --dont-prompt     -N |  --no-build   -p |  --use-nixpkgs     -a |  --auth   -b |  --branch     --tag     -c |  --commit   -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help  \u003C  MACHINE_NAME >    URL   MODULE_PATHS  Description  A code machine usually has one module that resides in the repository of\nthe project you want to develop. To create a machine with this module,\nuse the following command. Only the url to the repository is mandatory.\nCodchi will try to guess the rest of the information and prompt you if\nneccessary.  Options    -n ,   --dont-run-init  Do not execute the init script automatically (NixOS option\n  codchi.initScript )   -y ,   --dont-prompt  Dont prompt for confirmation and accept all of Codchis defaults.\nUsefull for using Codchi in scripts   -N ,   --no-build  Dont automatically build this machine after this command completes   -p ,   --use-nixpkgs =  USE_NIXPKGS  Whether to use Nixpkgs from the   local  Codchi installation or\nthe   remote  URL. See the \"Which nixpkgs should I use?\"\nsection of   codchi init  for more details.  By default Codchi will use   remote  if    defines a\nnixpkgs input in its flake. Otherwise it will use the   local \nnixpkgs.   *possible values: *local, remote   -a ,   --auth =  AUTH  Authorisation string for private repositories. Generally, the syntax\nis   \u003Cuser>:\u003Ctoken>  or just   \u003Ctoken> .  GitHub for example has something like\n  ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  whereas GitLab uses\n  oauth2:glpat-xxxxxxxxxxxxxxxxxxxx .   -b ,   --branch =  BRANCH  The git branch to use for the code machine module   --tag =  TAG  The git tag to use for the code machine module   -c ,   --commit =  COMMIT  The git commit to use for the code machine module   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  MACHINE_NAME >  Name of the code machine    URL  HTTP(S) URL to the git repository which holds the Codchi module.  When omitted Codchi will create a base machine without modules.    MODULE_PATHS  A list of flake paths to the Codchi modules you whish to add.\nCurrently supported: codchiModules.   or\nnixosModules.  . If not sure which modules are available,\nleave this empty. Codchi will prompt you with a list of possible\noptions.  With   --dont-prompt  this argument is required.  Extra  Which nixpkgs should I use?  Since every code machine is a NixOS system, it needs a version of\nnixpkgs (the collection containing all Nix programs). There are two\noptions:   Use Codchi's nixpkgs: Every release of codchi has a pinned version\nof nixpkgs which is consistent across all code machines on a given\nhost system. Because the Nix store is shared among all machines,\nthis results in fewer package downloads, saves disk space and is\nfaster during installation or updates. The downside is that code\nmachines aren't perfectly reproducibile anymore, since the nixpkgs\nversion can change with every Codchi version. In reality this\nshouldn't be a big deal because Codchi adheres to NixOS's release\nschedule (every 6 months) and keeps nixpkgs consistent across this\ntimespan.  Use the module's nixpkgs: If a module of a code machine has a\nnixpkgs input inside its   flake.nix , the code machine can use (Nix\nlanguage: \"follow\") it.   Pro: Exact reproducibility among machines with the same module\nand nixpkgs.  Con: More packages to download, more disk space and slower\nduring installation and updates.  Examples  Create a machine with a Java devenv:   codchi init \u003CMACHINE_NAME> https://github.com/aformatik/codchi nixosModules.jvm\n  Create a machine with Codchi's devenv (rust):   codchi init \u003CMACHINE_NAME> https://github.com/aformatik/codchi nixosModules.codchi\n  Let Codchi search for available modules in   \u003CREPO_URL>  and prompt you\nwith it:   codchi init \u003CMACHINE_NAME> \u003CREPO_URL>\n  Create an empty base machine:   codchi init \u003CMACHINE_NAME>\n",{"id":126,"path":127,"dir":128,"title":129,"description":130,"keywords":131,"body":132},"content:2.usage:module:add.md","/usage/module/add","module","codchi module add","Add a module to a code machine.",[68,70,71],"  codchi module add  Add a module to a code machine.  Synopsis   codchi module add     -y |  --dont-prompt   -N |  --no-build     -p |  --use-nixpkgs   -a |  --auth     -b |  --branch     --tag   -c |  --commit     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  MACHINE_NAME > \u003C  URL >    MODULE_PATHS  Options    -y ,   --dont-prompt  Dont prompt for confirmation and accept all of Codchis defaults.\nUsefull for using Codchi in scripts   -N ,   --no-build  Dont automatically build this machine after this command completes   -p ,   --use-nixpkgs =  USE_NIXPKGS  Whether to use Nixpkgs from the   local  Codchi installation or\nthe   remote  URL. See the \"Which nixpkgs should I use?\"\nsection of   codchi init  for more details.  By default Codchi will use   remote  if    defines a\nnixpkgs input in its flake. Otherwise it will use the   local \nnixpkgs.   *possible values: *local, remote   -a ,   --auth =  AUTH  Authorisation string for private repositories. Generally, the syntax\nis   \u003Cuser>:\u003Ctoken>  or just   \u003Ctoken> .  GitHub for example has something like\n  ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  whereas GitLab uses\n  oauth2:glpat-xxxxxxxxxxxxxxxxxxxx .   -b ,   --branch =  BRANCH  The git branch to use for the code machine module   --tag =  TAG  The git tag to use for the code machine module   -c ,   --commit =  COMMIT  The git commit to use for the code machine module   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  MACHINE_NAME >  Name of the code machine  \u003C  URL >  HTTP(S) URL or file path to the codchi module    MODULE_PATHS  A list of flake paths to the NixOS modules you whish to add.\nCurrently supported: codchiModules.   or\nnixosModules.   Examples  Personal modules  Sometimes you might want to customize a code machine, but don't want to\ncommit it to upstream to the main module of the code machine which is\nalso used by other developers. For example, you might want to use a\ndifferent editor than the rest of the project's contributors.\nFortunately, you can add as many modules to a machine as you like! This\nis especially handy for sharing your personal configuration between\ndifferent code machines:   codchi module add \u003CMACHINE_NAME> https://github.com/my/cool/nixconfig nixosModules.vim\n  Local modules  See the   EXTRA  section of   codchi module  for more information. Given\nyou already have a git repository containing a code machine module\nchecked out inside at the path   $HOME/my-additional-module . You can add\nit to the code machine via:   codchi module add \u003CMACHINE_NAME> my-additional-module \u003CMODULE_PATHS...>\n   Note that the (  my-additional-module ) is relative to     $HOME \ninside and has no leading   ~  or     ./ .  If you leave\n\u003CMODULE_PATHS...> empty, Codchi will prompt you with a list of\navailable modules, just like with   codchi init .",{"id":134,"path":135,"dir":128,"title":136,"description":137,"keywords":138,"body":139},"content:2.usage:module:delete.md","/usage/module/delete","codchi module delete","Delete a module of a code machine",[68,69,70],"  codchi module delete  Delete a module of a code machine  Synopsis   codchi module delete     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  NAME > \u003C  MODULE_NAME >  Description  Delete a module of a code machine.  This will   NOT  delete user data, even if its the last remaining\nmodule! It will only remove programs, services and other configuration\ndefined in that module.  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  NAME >  Name of the code machine  \u003C  MODULE_NAME >  Name of the module (You can list them with   codchi module ls NAME )",{"id":141,"path":142,"dir":128,"title":143,"description":144,"keywords":145,"body":146},"content:2.usage:module:list.md","/usage/module/list","codchi module list","Lists modules of a code machine",[68,70],"  codchi module list  Lists modules of a code machine  Synopsis   codchi module list     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  NAME >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  NAME >  Name of the code machine",{"id":148,"path":149,"dir":128,"title":150,"description":151,"keywords":152,"body":153},"content:2.usage:module:module.md","/usage/module/module","codchi module","Manage modules of code machines.",[68,69,79,70,109],"  codchi module  Manage modules of code machines.  Synopsis   codchi module     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  subcommands >  Description  Each code machine has a list of modules (often just one) which are\nidentified by a name. There can also be machines without modules (a base\nmachine). You can add, modify, remove a module or switch a module\nbetween local and remote configuration.  Subcommands   codchi-module-list(1)  Lists modules of a code machine  codchi-module-add(1)  Add a module to a code machine.  codchi-module-set(1)  Modify a module of a code machine.  codchi-module-delete(1)  Delete a module of a code machine  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  Extra  Local Configuration  While working on a code machine module, any change to the code must\nfirst be pushed online before Codchi can pull and apply the change. This\ncan quickly become annoying, especially if you're actively developing\nthe module or experimenting a lot. Luckily, a machine module can be\nswitched to local repository inside the code machine.  It's good practise to have the   .nix  configuration files in the\nrepository of your project itself. This way Codchi can spin up a machine\nfor every commit of your project. Also you'll have the project checked\nout in your code machine anyway, so step 1 shouldn't be neccessary.   First of all, clone the repository containing the module\nconfiguration inside . For Codchi to be able to find it, the\nrepository has reside in a folder inside the machine's   $HOME ,\nwhich is   /home/codchi .   git clone https://github.com/my/repo ~/my-project-name\n  Upon creation of , if you didn't explicitly specify a module name\nfor your repository, Codchi guesses a name from its url. List 's\nmodules to get the actual module name:   codchi module list \u003CMACHINE_NAME>\n┌─────────────┬────────────────────┬────────────────────────┐\n│ Name        ┆ Url                ┆ Flake Module           │\n╞═════════════╪════════════════════╪════════════════════════╡\n│ repo-module ┆ github.com/my/repo ┆ nixosModules.my-module │\n└─────────────┴────────────────────┴────────────────────────┘\n  Now you can tell Codchi to switch the module pointing to the remote\nrepository to your local copy. Note that that `my-project-name' is\nthe path inside relative to $HOME:   codchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --url=my-project-name\n  If you don't already have a module (e.g. after creating a base machine),\nyou can just add a module pointing to a local repository. The name of\nthe new module will be inferred by Codchi:   codchi module add \u003CMACHINE_NAME> my-project-name\n",{"id":155,"path":156,"dir":128,"title":157,"description":158,"keywords":159,"body":160},"content:2.usage:module:set.md","/usage/module/set","codchi module set","Modify a module of a code machine.",[68,69,70,71],"  codchi module set  Modify a module of a code machine.  Synopsis   codchi module set     -u |  --url   -y |  --dont-prompt     -N |  --no-build   -p |  --use-nixpkgs     -a |  --auth   -b |  --branch     --tag     -c |  --commit   -n |  --new-name     -m |  --module-path   -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help  \u003C  MACHINE_NAME > \u003C  NAME >  Description  Change the upstream url, switch the git branch, rename the module, edit\naccess information, switch between remote and local repositories or set\nwhich nixpkgs to use.  Options    -u ,   --url =  URL  HTTP(S) URL or file path to the repository of the module   -y ,   --dont-prompt  Dont prompt for confirmation and accept all of Codchis defaults.\nUsefull for using Codchi in scripts   -N ,   --no-build  Dont automatically build this machine after this command completes   -p ,   --use-nixpkgs =  USE_NIXPKGS  Whether to use Nixpkgs from the   local  Codchi installation or\nthe   remote  URL. See the \"Which nixpkgs should I use?\"\nsection of   codchi init  for more details.  By default Codchi will use   remote  if    defines a\nnixpkgs input in its flake. Otherwise it will use the   local \nnixpkgs.   *possible values: *local, remote   -a ,   --auth =  AUTH  Authorisation string for private repositories. Generally, the syntax\nis   \u003Cuser>:\u003Ctoken>  or just   \u003Ctoken> .  GitHub for example has something like\n  ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  whereas GitLab uses\n  oauth2:glpat-xxxxxxxxxxxxxxxxxxxx .   -b ,   --branch =  BRANCH  The git branch to use for the code machine module   --tag =  TAG  The git tag to use for the code machine module   -c ,   --commit =  COMMIT  The git commit to use for the code machine module   -n ,   --new-name =  NEW_NAME  The new name of the module => TODO mod rename command   -m ,   --module-path =  MODULE_PATH  The flake path to the NixOS module you whish to use. Currently\nsupported: codchiModules.   or nixosModules.    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  MACHINE_NAME >  Name of the code machine  \u003C  NAME >  The name of the module to modify  Examples  Change the branch of :   codchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --branch develop\n  Rename to   codchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --new-name \u003CNEW_NAME>\n  Switch the upstream URL:   codchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --url https://github.com/my/new/repo\n  Switch to a module inside   \u003CCODE_MACHINE>  See the   EXTRA  section of   codchi module  for more information.\n  Note that the (  my-project-name ) points to a git  repository\nrelative to    $HOME  inside and has no leading     ~  or   ./ .   codchi module set \u003CMACHINE_NAME> \u003CMODULE_NAME> --url=my-project-name\n",{"id":162,"path":163,"dir":64,"title":164,"description":165,"keywords":166,"body":167},"content:2.usage:rebuild.md","/usage/rebuild","codchi rebuild","Apply changes to a code machine. By default this also fetches updates\nfor each module.",[68,69,70,71],"  codchi rebuild  Apply changes to a code machine. By default this also fetches updates\nfor each module.  Synopsis   codchi rebuild     -n |  --no-update   -v |  --verbose ...    -q |  --quiet ...\n   --json     -h |  --help  \u003C  NAME >  Description  When a code machine is modified, it needs to be rebuilt in order to\napply the changes. Modifications include:   A module was added, modified or removed  The configuration of a remote module was modified  The configuration of a local module was modified  To prevent the fetching of updates, use   --no-update .  Options    -n ,   --no-update  Dont fetch module updates   -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)  \u003C  NAME >  Name of the code machine  Examples  Apply local and remote changes:   codchi rebuild \u003CMACHINE_NAME>\n  Apply only local changes:   codchi rebuild \u003CMACHINE_NAME> --no-update\n",{"id":169,"path":170,"dir":171,"title":172,"description":173,"keywords":174,"body":175},"content:2.usage:secrets:get.md","/usage/secrets/get","secrets","codchi secrets get","Get the current value of a secret",[68,70],"  codchi secrets get  Get the current value of a secret  Synopsis   codchi secrets get     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  MACHINE_NAME > \u003C  SECRET_NAME >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  MACHINE_NAME >  Name of the code machine  \u003C  SECRET_NAME >  Name of the secret",{"id":177,"path":178,"dir":171,"title":179,"description":180,"keywords":181,"body":182},"content:2.usage:secrets:list.md","/usage/secrets/list","codchi secrets list","Lists secrets of a code machine",[68,70],"  codchi secrets list  Lists secrets of a code machine  Synopsis   codchi secrets list     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  NAME >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  NAME >  Name of the code machine",{"id":184,"path":185,"dir":171,"title":186,"description":187,"keywords":188,"body":189},"content:2.usage:secrets:secrets.md","/usage/secrets/secrets","codchi secrets","Manage secrets of code machines.",[68,69,79,70],"  codchi secrets  Manage secrets of code machines.  Synopsis   codchi secrets     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  subcommands >  Description  Sometimes there is the need for user-specific variables and / or\nsecrets, which should not be included inside the .nix files inside a git\nrepository, but they're still needed for the development environment. An\nexample is a GitHub / GitLab token which is used to automatically setup\nmail and username for Git's config.  See    for more information.  Subcommands   codchi-secrets-list(1)  Lists secrets of a code machine  codchi-secrets-get(1)  Get the current value of a secret  codchi-secrets-set(1)  Change the value of an existing secret. The machine needs to be\nrestarted after modifying secrets  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help (see a summary with -h)",{"id":191,"path":192,"dir":171,"title":193,"description":194,"keywords":195,"body":196},"content:2.usage:secrets:set.md","/usage/secrets/set","codchi secrets set","Change the value of an existing secret. The machine needs to be\nrestarted after modifying secrets",[68,70],"  codchi secrets set  Change the value of an existing secret. The machine needs to be\nrestarted after modifying secrets  Synopsis   codchi secrets set     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  MACHINE_NAME > \u003C  SECRET_NAME >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  MACHINE_NAME >  Name of the code machine  \u003C  SECRET_NAME >  Name of the secret",{"id":198,"path":199,"dir":64,"title":200,"description":201,"keywords":202,"body":203},"content:2.usage:status.md","/usage/status","codchi status","List installed code machines and their status",[68,70],"  codchi status  List installed code machines and their status  Synopsis   codchi status     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help",{"id":205,"path":206,"dir":207,"title":208,"description":209,"keywords":210,"body":211},"content:2.usage:store:debug.md","/usage/store/debug","store","codchi store debug","Open a debug shell inside codchistore without starting / requiring any\nservices. Usefull for debugging.",[68,70],"  codchi store debug  Open a debug shell inside   codchistore  without starting / requiring any\nservices. Usefull for debugging.  Synopsis   codchi store debug     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help",{"id":213,"path":214,"dir":207,"title":215,"description":216,"keywords":217,"body":218},"content:2.usage:store:store.md","/usage/store/store","codchi store","Utilities for interacting with the codchistore container.",[68,79,70],"  codchi store  Utilities for interacting with the   codchistore  container.  Synopsis   codchi store     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  subcommands >  Subcommands   codchi-store-debug(1)  Open a debug shell inside   codchistore  without starting /\nrequiring any services. Usefull for debugging.  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help",{"id":220,"path":221,"dir":64,"title":222,"description":223,"keywords":224,"body":225},"content:2.usage:tar.md","/usage/tar","codchi tar","Export the file system of a code machine including NixOS configuration\nand codchi secrets.",[68,70],"  codchi tar  Export the file system of a code machine including NixOS configuration\nand codchi secrets.  Synopsis   codchi tar     -v |  --verbose ...\n   -q |  --quiet ...    --json     -h |  --help \n\u003C  NAME > \u003C  TARGET_FILE >  Options    -v ,   --verbose  Increase logging verbosity   -q ,   --quiet  Decrease logging verbosity   --json  Produce output in JSON format, suitable for consumption by another\nprogram   -h ,   --help  Print help  \u003C  NAME >  Name of the code machine  \u003C  TARGET_FILE >  Path to export to",{"id":227,"path":228,"dir":229,"title":230,"description":231,"keywords":232,"body":234},"content:3.config:0.overview.md","/config/overview","config","Overview","Every code machine is a NixOS system consisting of a range of Codchi modules, each corresponding to a NixOS module. So, configuring a code machine is the same as configuring a NixOS system, without you having to worry about hardware configuration.",[233],"Additional Resources","  Overview  Every code machine is a NixOS system consisting of a range of Codchi modules, each corresponding to a NixOS module. So, configuring a code machine is the same as configuring a NixOS system, without you having to worry about hardware configuration.  A NixOS module is written in Nix's own configuration language with the same name. Nix (the language) can be described as \"JSON with functions\". To write your first Codchi module,   read   the tutorial  and look at   the examples  and the language specific chapters in this section.  If you want to get deeper into Nix, there is   the   official Nix Guide  the   NixOS Manual  and the   NixOS Wiki .  You can also as questions by    creating an GitHub issue  or in the   Nix Discourse .  During module development, you most likely don't want to push after every config change. To switch your code machine to your local working copy, see chapter   Local Configuration .  Additional Resources   Search more than 10 000 NixOS options and 100 000 Nix packages available in Codchi:   https://search.nixos.org  [Codchi-specific NixOS options](./99.Codchi specific NixOS Options.md)",{"id":236,"path":237,"dir":229,"title":238,"description":239,"keywords":240,"body":241},"content:3.config:1.start.md","/config/start","Your first Module","Configuring a code machine means configuring a NixOS module. Don't worry, if you've never done this, it is really simple: In your project's git repository, create a file called configuration.nix with the following content:",[],"  Your first Module  Configuring a code machine means configuring a NixOS module. Don't worry, if you've never done this, it is really simple: In your project's git repository, create a file called   configuration.nix  with the following content:     { pkgs  ,   ...   }: { \n       environment  .  systemPackages   =   [   pkgs  .  neofetch   ];\n   }\n  For Codchi to be able to pick it up, you also need to create a   flake.nix  in the root directory of your repository:     {\n     description   =   \"My awesome code machine\"  ;\n     outputs   =   {   ...   }: {\n       nixosModules  .  myModule   =   ./configuration.nix  ;\n     };\n   }\n  Make sure that the path to   configuration.nix  is correct. It must start with   ./ ! Now push both files to a code forge of your choice and create a code machine:     codchi   init   myMachine   https://github.com/my/repo   nixosModules.myModule\n  Notice that   nixosModules.myModule  is from   flake.nix , so make sure they match! Now build the machine and run   neofetch :     codchi   rebuild   myMachine\n   codchi   exec   myMachine   neofetch\n             ▗▄▄▄         ▗▄▄▄▄      ▄▄▄▖              codchi@nixos\n             ▜███▙         ▜███▙    ▟███▛              ------------\n              ▜███▙         ▜███▙▟███▛               OS:   NixOS   x86_64\n               ▜███▙         ▜██████▛                Host:   ...\n        ▟█████████████████▙   ▜████▛       ▟▙          Kernel:   6.1.64\n       ▟███████████████████▙   ▜███▙      ▟██▙         Uptime:   ...\n              ▄▄▄▄▖             ▜███▙    ▟███▛         Packages:   383   (nix-system)\n             ▟███▛               ▜██▛   ▟███▛          Shell:   bash   5.2.15\n            ▟███▛                 ▜▛   ▟███▛           Resolution:   1920x1080\n   ▟███████████▛                    ▟██████████▙     CPU:   ...\n   ▜██████████▛                    ▟███████████▛     GPU:   ...\n         ▟███▛   ▟▙                 ▟███▛              GPU:   ...\n        ▟███▛   ▟██▙               ▟███▛               Memory:   19MiB   /   ...\n       ▟███▛    ▜███▙             ▝▀▀▀▀\n       ▜██▛      ▜███▙   ▜██████████████████▛\n        ▜▛       ▟████▙   ▜████████████████▛\n              ▟██████▙         ▜███▙\n             ▟███▛▜███▙         ▜███▙\n            ▟███▛    ▜███▙         ▜███▙\n            ▝▀▀▀      ▀▀▀▀▘         ▀▀▀▘\n  Congratulations, you've configured your first code machine!  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":243,"path":244,"dir":229,"title":245,"description":246,"keywords":247,"body":249},"content:3.config:2.secrets.md","/config/secrets","Secrets","Sometimes there is the need for user-specific variables and / or secrets, which should not be included inside the .nix files inside a git repository, but they're still needed for the development environment. An example is a GitHub / GitLab token which is used to automatically setup mail and username for Git's config.",[248],"Modifying secrets","  Secrets  Sometimes there is the need for user-specific variables and / or secrets, which should not be included inside the   .nix  files inside a git repository, but they're still needed for the development environment. An example is a GitHub / GitLab token which is used to automatically setup mail and username for Git's config.  With Codchi these secrets can be   described  via NixOS options. Lateron, when a user installs a machine with this config, Codchi will prompt him to enter the specific secret value. The value is then made available via environment variables inside the machine.    Warning    Codchi stores secret values in plain text on the host. Also they are available via plain environment variables inside a code machine. Therefore they should not be used for super sensitive secrets.  Here's an example:     # configuration.nix\n   {\n     codchi  .  secrets  .  env  .  TEST   =   {\n         description   =   ''\n           This is an example secret. Please enter a random value!\n         ''  ;\n     };\n   }\n  We define the secret   TEST  and provide a description. When we build this code machine, we'll be prompted for a value for   TEST :     >   codchi rebuild foo\n   ...\n   ?   Please enter secret   'TEST'   (  Toggle   input   mask   with   \u003C  Ctrl+  R  >  ): My Secret Value\n   [This is an example secret. Please enter a random value  !  ]\n   ...\n   \n   >   codchi exec foo\n   [codchi@nixos:  ~  ]$ env   |   grep   CODCHI\n   CODCHI_TEST  =  My   Secret   Value\n   ...\n  We can also use this secret inside systemd services (which run automatically on machine startup). For this we have to source   /etc/codchi-env  on service startup:     # configuration.nix\n   { \n     systemd  .  services  .  my-secret-service   =   {\n       description   =   \"My Service which reads Codchi's secrets\"  ;\n       wantedBy   =   [   \"multi-user.target\"   ];\n   \n       script   =   ''\n         source /etc/codchi-env\n         echo \"Got secret CODCHI_TEST=$CODCHI_TEST from codchi\"\n       ''  ;\n     };\n   }\n  We can view the latest log lines of the service:     [codchi@nixos:  ~  ]$ sudo systemctl status my-secret-service.service\n   ○   my-secret-service.service   -   My   Service   which   reads   codchi's secrets\n        Loaded: loaded (/etc/systemd/system/my-secret-service.service; enabled; preset: enabled)\n       Drop-In: /nix/store/rrvw6pahhcvvhgp7vqb6v3pps1c7dl6v-system-units/service.d\n                └─zzz-lxc-service.conf\n        Active: inactive (dead) since Tue 2024-07-09 09:38:52 UTC; 3min 13s ago\n      Duration: 3ms\n       Process: 173 ExecStart=/nix/store/hv0hsyi0vb8va1jfnc03py7nylh2528c-unit-script-my-secret-service-start/bin/my-secret-service-start (code=exited, status=0/SUCCESS)\n      Main PID: 173 (code=exited, status=0/SUCCESS)\n           CPU: 3ms\n   \n   Jul 09 09:38:52 nixos systemd[1]: Started My Service which reads codchi's   secrets.\n   Jul   09   09:38:52   nixos   my-secret-service-start[173]:   Got   secret   CODCHI_TEST=My   Secret   Value   from   codchi   \u003C  ------------------------------------------\n   Jul   09   09:38:52   nixos   systemd[1]:   my-secret-service.service:   Deactivated   successfully.\n  Refer to the   NixOS Options Reference  for more details.  Modifying secrets  Please refer to the    codchi secrets  docs .  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":251,"path":252,"dir":229,"title":253,"description":7,"keywords":254,"body":259},"content:3.config:3.misc.md","/config/misc","Miscellaneous",[255,256,257,258],"Welcome Message","Docker","Time Zone","Windows Networking","  Miscellaneous  Welcome Message  When opening a shell into a code machine, the user is greeted with the following message:   ❄️ Welcome to your code machine! ❄️\n\nTo get started with Codchi, read the docs at \u003Chttps://codchi.dev/>.\nIf you encounter problems please open an issue at \u003Chttps://github.com/aformatik/codchi/issues>.\n  To customize this, for example to give the user instructions on how to procceed further, there is [  codchi.welcome.text ](./99.Codchi specific NixOS Options.md#codchiwelcometext) and [  codchi.welcome.extraText ](./99.Codchi specific NixOS Options.md#codchiwelcomeextratext).  Docker  Docker works normally in Codchi, but the user   codchi  has to be added to the corresponding group in order to not require   sudo . Codchi provides the convenience option [  codchi.docker.enable ](./99.Codchi specific NixOS Options.md#codchidockerenable) for this.     { pkgs  ,   ...   }: {\n     codchi  .  docker  .  enable   =   true  ;\n   }\n  Time Zone  By default the time zone is UTC inside a code machine. You can change this via     {\n       time  .  timeZone   =   \"Europe/Berlin\"  ;\n   }\n  Windows Networking  By default WSL configures the   /etc/hosts  and   /etc/resolv.conf  to match the networking settings of the host. Therefore they can't be generated by NixOS / Codchi. While Windows' DNS settings (through   /etc/resolv.conf ) are often neccessary for a working WSL instance,   /etc/hosts  is overridden by Codchi to enable reproducible IP / Domain configuration.  To override this change these options:     {\n     environment  .  etc   =   {\n       hosts  .  enable   =   true  ;   # /etc/hosts set by Codchi\n       \"resolv.conf\"  .  enable   =   false  ;   # /etc/hosts set by WSL\n     };\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":261,"path":262,"dir":229,"title":263,"description":7,"keywords":264,"body":267},"content:3.config:4.devenv.md","/config/devenv","flake.nix, devenv.sh, flox",[265,266],"flake.nix","devenv.sh, flox","  flake.nix, devenv.sh, flox  flake.nix  Because a code machine is just a NixOS machine with flakes enabled, even a empty code machine supports flakes per default (try   codchi init \u003CNAME>  without args!). But you can use the configuration to provide tools which the flake doesn't provide:     { pkgs  ,   ...   }: {\n   \n     # Direnv support\n     direnv   =   {\n       enable   =   true  ;\n       enableBashIntegration   =   true  ;\n       # use_nix and use_flake support\n       nix-direnv  .  enable   =   true  ;\n     };\n   \n     # See \u003Chttps://codchi.dev/config/editor> on how to add an editor\n   }\n  devenv.sh, flox  As described in   the intro , Codchi doesn't try to do the job of tools like   devenv.sh  or   flox . Instead, both can be used together, each for their respective purpose: Codchi provides a consistent environment across Windows and Linux and devenv.sh or flox provide the development environment itself.     { pkgs  ,   ...   }: {\n   \n     # For direnv support\n     # direnv = {\n     #   enable = true;\n     #   enableBashIntegration = true;\n     #   # use_nix and use_flake support\n     #   nix-direnv.enable = true;\n     # };\n   \n     environment  .  systemPackages   =   [\n       pkgs  .  devenv\n       # Or see \u003Chttps://flox.dev/docs/install-flox/#install-flox-from-scratch> on how to install flox\n     ];\n   \n     # See \u003Chttps://codchi.dev/config/editor> on how to add an editor\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":269,"path":270,"dir":229,"title":271,"description":7,"keywords":272,"body":276},"content:3.config:5.editor.md","/config/editor","Editor",[273,274,275],"VSCode","Jetbrains IDEs","Vim","  Editor  VSCode  VSCode can be had in two flavours: The proprietary   pkgs.vscode  from Microsoft and the free   pkgs.vscodium . On top of that VSCode can be installed preconfigured with plugins. When manually installing plugins via VSCode, there can be issues if a plugin tries to install native binaries. In this case   pkgs.vscode-fhs  and   pkgs.vscodium-fhs  provide a FHS environment in which most plugins should work.\nSee   https://wiki.nixos.org/wiki/Vscode  for more info.     { pkgs  ,   ...   }: {\n     environment  .  systemPackages   =   [\n       # Plain VSCode\n       pkgs  .  vscodium\n   \n       # With plugins\n       (  pkgs  .  vscode-with-extensions  .  override   {\n         vscode   =   pkgs  .  vscodium  ;\n         vscodeExtensions   =   with   vscode-extensions  ; [\n           bbenoist  .  nix\n           ms-python  .  python\n           ms-azuretools  .  vscode-docker\n           ms-vscode-remote  .  remote-ssh\n         ]   ++   pkgs  .  vscode-utils  .  extensionsFromVscodeMarketplace   [\n           {\n             name   =   \"remote-ssh-edit\"  ;\n             publisher   =   \"ms-vscode-remote\"  ;\n             version   =   \"0.47.2\"  ;\n             sha256   =   \"1hp6gjh4xp2m1xlm1jsdzxw9d8frkiidhph6nvl24d0h8z34w49g\"  ;\n           }\n         ];\n       })\n   \n       # FHS env\n       pkgs  .  vscodium-fhs\n     ];\n   }\n  Jetbrains IDEs  See chapter   JVM  on how to setup JDKs for Java IDEs like IntelliJ.  All Jetbrains IDEs are available under   pkgs.jetbrains.\u003CIDE> . See the   NixOS Search  for a list of available IDEs.  There is also the experimental   pkgs.jetbrains.plugins.addPlugidea-communityins  which can add plugins to a Jetbrains IDE. See   https://github.com/NixOS/nixpkgs/tree/nixos-24.05/pkgs/applications/editors/jetbrains  for more details.     { pkgs  ,   ...   }: {\n   \n     # Setup JDKs if neccessary\n   \n     environment  .  systemPackages   =   [\n       pkgs  .  jetbrains  .  idea-community\n   \n       pkgs  .  jetbrains  .  idea-ultimate\n   \n       # With plugins\n       (  with   pkgs  .  jetbrains  ;   plugins  .  addPlugins   pycharm-community   [\n         \"nixidea\"\n         \"ideavim\"\n       ])\n   \n     ];\n   \n     # For proprietary apps like IntelliJ Ultimate\n     nixpkgs  .  config  .  allowUnfree   =   true  ;\n   }\n  Vim  There are a few options available:   Plain   pkgs.vim  /   pkgs.neovim  Configuring NeoVim via NixOS options:   https://wiki.nixos.org/wiki/Neovim#Configuration   LunarVim    pkgs.lunarvim   nixvim  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":278,"path":279,"dir":280,"title":281,"description":7,"keywords":282,"body":284},"content:3.config:6.environments:gpu.md","/config/environments/gpu","environments","GPU",[283],"Nvidia","  GPU   Try it out with   codchi init \u003CNAME> https://github.com/aformatik/codchi nixosModules.gpu .  GPU usage should work by default inside a code machine. Codchi uses the GPU driver from your host and therefore only works when the driver is installed on your host. Currently only Nvidia/CUDA is tested.  Nvidia  Check if it works     codchi   init   gpu_test   # create an empty machine\n   codchi   exec   gpu_test   nvidia-smi\n   # Output should look similar to this:\n   +---------------------------------------------------------------------------------------+\n   |   NVIDIA-SMI   535.157                  Driver   Version:   538.18         CUDA   Version:   12.2       |\n   |  -----------------------------------------+----------------------+----------------------+\n   |   GPU    Name                   Persistence-M   |   Bus-Id          Disp.A   |   Volatile   Uncorr.   ECC   |\n   |   Fan    Temp     Perf            Pwr:Usage/Cap   |           Memory-Usage   |   GPU-Util    Compute   M.   |\n   |                                           |                        |                 MIG   M.   |\n   |  =========================================+======================+======================  |\n   |     0    Quadro   P500                      On    |   00000000:02:00.0   Off   |                    N/A   |\n   |   N/A     55C      P0                N/A   /   ERR!   |        0MiB   /    2048MiB   |        1%        Default   |\n   |                                           |                        |                    N/A   |\n   +-----------------------------------------+----------------------+----------------------+\n                                                                                            \n   +---------------------------------------------------------------------------------------+\n   |   Processes:                                                                              |\n   |    GPU     GI     CI          PID     Type     Process   name                              GPU   Memory   |\n   |          ID     ID                                                               Usage        |\n   |  =======================================================================================  |\n   |    No   running   processes   found                                                             |\n   +---------------------------------------------------------------------------------------+\n  nvidia-container-toolkit  To use your GPU inside Docker inside a code machine, enable   codchi.docker.enableNvidia . This also requires requires   nixpkgs.config.allowUnfree = true .  For example, here is how you can run   InvokeAI  inside a code machine:     codchi   init   invokeai    https://github.com/aformatik/codchi   nixosModules.gpu\n   codchi   exec   invokeai\n   # on NixOS>=24.11\n   docker   run   --runtime=nvidia   --device   nvidia.com/gpu=all   --publish   9090:9090   ghcr.io/invoke-ai/invokeai\n   # on NixOS\u003C24.11\n   docker   run   --runtime=nvidia   --gpus=all   --publish   9090:9090   ghcr.io/invoke-ai/invokeai\n   # open web ui in your windows browser (in another terminal)\n   xdg-open   \"http://$(  ip   route   |   awk   '/^default/{print $3; exit}'):9090\"\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":286,"path":287,"dir":280,"title":288,"description":7,"keywords":289,"body":290},"content:3.config:6.environments:javascript.md","/config/environments/javascript","Javascript",[],"  Javascript   Try it out with   codchi init \u003CNAME> https://github.com/aformatik/codchi nixosModules.javascript .     { pkgs  ,   ...   }: {\n     programs  .  npm   =   {\n       enable   =   true  ;\n       # If you want a specific version\n       # package = pkgs.nodePackages_13_x.npm;\n   \n       # Configure npm if needed:\n       # npmrc = ''\n       #   prefix = ''${HOME}/.npm\n       #   https-proxy=proxy.example.com\n       #   init-license=MIT\n       #   init-author-url=https://www.npmjs.com/\n       #   color=true\n       # '';\n     };\n   \n     environment  .  systemPackages   =   [\n       pkgs  .  nodejs\n       # or a specific version:\n       # pkgs.nodejs_22\n   \n       # Deno:\n       pkgs  .  deno\n       \n       # Bun:\n       pkgs  .  bun\n   \n       # Other tools:\n       # pkgs.biome\n       # pkgs.nodePackages.prettier\n   \n       # Editor:\n       # See \u003Chttps://codchi.dev/config/editor> for more info\n       pkgs  .  vscodium\n       # Or, if you have problems with manually installed plugins:\n       # pkgs.vscodium-fhs\n     ];\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":292,"path":293,"dir":280,"title":294,"description":7,"keywords":295,"body":299},"content:3.config:6.environments:jvm.md","/config/environments/jvm","JVM",[296,297,298],"General, Java & Kotlin","Scala","Eclipse","  JVM   Try it out with   codchi init \u003CNAME> https://github.com/aformatik/codchi nixosModules.jvm .  General, Java & Kotlin  IntelliJ wants to download JDKs automatically, but they don't work on NixOS. Therefore you need to enable   programs.java  which sets   $JAVA_HOME  to the default JDK (OpenJDK) which IntelliJ can use. If multiple JDKs are needed, use [  programs.java.packages ](../99.Codchi specific NixOS Options.md#programsjavapackages) (an option added by Codchi) which installes them in   ~/.jdks .     { pkgs  ,   ...   }: {\n     programs  .  java   =   {\n       enable   =   true  ;\n       # Set default JDK\n       package   =   pkgs  .  jdk21  ;\n       packages   =   {\n         # Additional JDKs which get symlinked to ~/.jdks/\u003Cattribute name> (for e.g. IntelliJ)\n         openjdk8   =   pkgs  .  jdk8  ;\n         # ...\n       };\n     };\n   \n   \n     environment  .  systemPackages   =   [\n       pkgs  .  maven\n       # If you want gradle globally installed\n       # pkgs.gradle\n   \n       # IntelliJ Community\n       # pkgs.jetbrains.idea-community\n   \n       # You can also install IJ with plugins (experimental).\n       # For more information see \u003Chttps://github.com/NixOS/nixpkgs/tree/nixos-24.05/pkgs/applications/editors/jetbrains>\n       (  with   pkgs  .  jetbrains  ;   plugins  .  addPlugins   idea-community   [\n         \"nixidea\"\n         \"ideavim\"\n       ])\n   \n     ];\n   \n     # For proprietary apps like IntelliJ Ultimate\n     # nixpkgs.config.allowUnfree = true;\n   }\n  Scala     { pkgs  ,   ...   }: {\n     # Will be recognized by IntelliJ\n     environment  .  systemPackages   =   [   pkgs  .  scala   pkgs  .  sbt   ];\n   }\n  Eclipse     { pkgs  ,   ...   }: {\n     environment  .  systemPackages   =   [ \n       pkgs  .  eclipses  .  eclipse-java\n       # for JEE\n       # pkgs.eclipses.eclipse-jee \n     ];\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":301,"path":302,"dir":280,"title":303,"description":304,"keywords":305,"body":306},"content:3.config:6.environments:nix.md","/config/environments/nix","Nix","If you're editing Nix files often (e.g when working on a local code machine module), it makes sense to add editor support for Nix:",[],"  Nix  If you're editing Nix files often (e.g when working on a local code machine module), it makes sense to add editor support for Nix:     { pkgs  ,   ...   }: {\n     environment  .  systemPackages   =   with   pkgs  ; [\n       # Formatter\n       pkgs  .  nixpkgs-fmt\n   \n       # VSCode\n       (  vscode-with-extensions  .  override   {\n         vscodeExtensions   =   with   vscode-extensions  ; [\n           bbenoist  .  nix\n         ];\n       })\n   \n       # A language server if you have an editor with LSP support:\n       pkgs  .  nixd\n       # or\n       pkgs  .  nil\n     ];\n   }\n  For more options see   https://wiki.nixos.org/wiki/Editor_Modes_for_Nix_Files  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":308,"path":309,"dir":280,"title":310,"description":7,"keywords":311,"body":312},"content:3.config:6.environments:python.md","/config/environments/python","Python",[],"  Python   Try it out with   codchi init \u003CNAME> https://github.com/aformatik/codchi nixosModules.python .     { pkgs  ,   ...   }: {\n     environment  .  systemPackages   =   [\n       pkgs  .  python39\n       # Pip on NixOS only works in virtualenv\n       pkgs  .  python39Packages  .  pip\n       pkgs  .  python39Packages  .  virtualenv\n   \n       # Editor:\n       # See \u003Chttps://codchi.dev/config/editor> for more info\n       pkgs  .  jetbrains  .  pycharm-community\n       # Or VSCode(ium)\n       (  pkgs  .  vscode-with-extensions  .  override   {\n         vscode   =   pkgs  .  vscodium  ;\n         vscodeExtensions   =   with   pkgs  .  vscode-extensions  ; [\n           ms-python  .  python\n         ];\n       })\n     ];\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":314,"path":315,"dir":280,"title":316,"description":7,"keywords":317,"body":320},"content:3.config:6.environments:rust.md","/config/environments/rust","Rust",[318,319],"Rust via flakes","Rust via NixOS","  Rust  Rust via flakes   Try it out with   codchi clone \u003CNAME> https://github.com/aformatik/codchi nixosModules.codchi .  There is already great support for Rust development environments via Nix Flakes. Additionally to providing a development environment, this method also allows building the Rust project itself. Codchi itself uses this approach.  To use this method with Codchi, just install an IDE (and optionally nix-direnv) like   Codchi's code machine  does:     { pkgs  ,   ...   }:\n   {\n     environment  .  systemPackages   =   [\n       (  pkgs  .  vscode-with-extensions  .  override   {\n         vscode   =   pkgs  .  vscodium  ;\n         vscodeExtensions   =   with   pkgs  .  vscode-extensions  ; [\n           rust-lang  .  rust-analyzer\n           jnoortheen  .  nix-ide\n           mkhl  .  direnv\n           asvetliakov  .  vscode-neovim\n         ];\n       })\n       pkgs  .  bashInteractive   # fix terminal in VSCode\n     ];\n     programs  .  neovim  .  enable   =   true  ;   # needed for vscode-neovim plugin\n     programs  .  direnv   =   {\n       enable   =   true  ;\n       nix-direnv  .  enable   =   true  ;\n     };\n   }\n  When not using direnv and its IDE integration, the IDE must be started from within the Nix Flakes devshell:     cd   my/project\n   nix   develop\n   codium   .\n  Rust via NixOS  Cargo can also be installed globally. For this we recommend   oxalica/rust-overlay , a rustup-like distribution of rust within the Nix ecosystem.   Try it out with   codchi init \u003CNAME> https://github.com/aformatik/codchi nixosModules.rust .     { pkgs  ,   ...   }: {\n   \n     # https://github.com/oxalica/rust-overlay\n     nixpkgs  .  overlays   =   [\n       (self: super:\n         let\n           overlay   =   super  .  fetchFromGitHub   {\n             repo   =   \"rust-overlay\"  ;\n             owner   =   \"oxalica\"  ;\n             sha256   =   \"1bp1k5qla5gwh6vc50m5pcwdfxn6g703yx1i8qrjs4l7kgh3y507\"  ;\n             rev   =   \"573c674a3ad06e8a525263185ebef336a411d1d5\"  ;\n           };\n         in\n         {\n           inherit   (  import   overlay   self   super  )   rust-bin  ;\n         }\n       )\n     ];\n   \n     environment  .  systemPackages   =   [\n   \n       pkgs  .  gcc\n   \n       # https://github.com/oxalica/rust-overlay\n       (\n         let\n           rustConfig   =   {\n             extensions   =   [\n               \"rust-src\"\n               \"rust-analyzer\"\n             ];\n             targets   =   [\n               \"x86_64-unknown-linux-gnu\"\n               \"wasm32-wasi\"\n             ];\n           };\n         in\n         # stable\n         pkgs  .  rust-bin  .  stable  .  latest  .  default  .  override   rustConfig\n         # nightly\n         # pkgs.rust-bin.selectLatestNightlyWith (toolchain: toolchain.default.override rustConfig);\n       )\n   \n       # You can also install IJ with plugins (experimental).\n       # For more information see \u003Chttps://github.com/NixOS/nixpkgs/tree/nixos-24.05/pkgs/applications/editors/jetbrains>\n       (  with   pkgs  .  jetbrains  ;   plugins  .  addPlugins   rust-rover   [\n         \"nixidea\"\n       ])\n   \n       # When using VSCode instead of RustRover\n       # (pkgs.vscode-with-extensions.override {\n       #   vscode = pkgs.vscodium;\n       #   vscodeExtensions = with pkgs.vscode-extensions; [\n       #     rust-lang.rust-analyzer\n       #     jnoortheen.nix-ide\n       #   ];\n       # })\n       # pkgs.bashInteractive # fix terminal in VSCode\n     ];\n   \n     # For proprietary apps like RustRover\n     nixpkgs  .  config  .  allowUnfree   =   true  ;\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":322,"path":323,"dir":229,"title":324,"description":7,"keywords":325,"body":336},"content:3.config:99.Codchi specific NixOS Options.md","/config/codchi-specific-nixos-options","Codchi Specific NixOS Options",[326,327,328,329,330,331,332,333,334,335],"codchi.enableRecommendedConfig","codchi.docker.enable","codchi.docker.enableNvidia","codchi.gpu.enable","codchi.initScript","codchi.keyring.enable","codchi.secrets.env","codchi.secrets.env.\u003Cname>.description","codchi.secrets.env.\u003Cname>.name","programs.java.packages","  codchi.enableRecommendedConfig  Whether to enable recommended NixOS options.   Type: \nboolean   Default:  true   Example:  true   Declared by:    \u003Ccodchi/nix/nixos/modules/recommended-config.nix>  codchi.docker.enable  Whether to enable the docker daemon. This also adds the codchi user to the docker group and installs docker-compose.   Type: \nboolean   Default:  false   Declared by:    \u003Ccodchi/nix/nixos/modules/docker.nix>  codchi.docker.enableNvidia  Whether to install nvidia-container-toolkit to enable GPU usage inside docker containers.\nThis requires setting   codchi.gpu.enable = true  and   nixpkgs.config.allowUnfree = true .   Type: \nboolean   Default:  false   Declared by:    \u003Ccodchi/nix/nixos/modules/docker.nix>  codchi.gpu.enable  Whether to enable OpenGL / GPU driver from the host.   Type: \nboolean   Default:  true   Example:  true   Declared by:    \u003Ccodchi/nix/nixos/driver/host-integration.nix>  codchi.initScript  A bash script which will run once on machine creation (init or clone) as the default codchi user. Afterwards it can be run manually via   codchi-init .  To override the default welcome message use   lib.mkForce .   Type: \nnull or strings concatenated with “\\n”   Default:   ''\n  echo -e \"❄️ Welcome to your new code machine $CODCHI_MACHINE_NAME! ❄️\"\n  echo\n  echo -e \"To get started with \\e[1;36mCodchi\\e[0m, read the docs at \u003Chttps://codchi.dev/>.\"\n  echo -e \"If you encounter problems please open an issue at \u003Chttps://github.com/aformatik/codchi/issues>.\"\n  echo\n''\n   Example:   ''\n  cd $HOME\n  git clone https://github.com/my/cool-repo\n''\n   Declared by:    \u003Ccodchi/nix/nixos/driver/init.nix>  codchi.keyring.enable  Whether to enable a keyring for applications like IntelliJ.   Type: \nboolean   Default:  false   Example:  true   Declared by:    \u003Ccodchi/nix/nixos/modules/keyring.nix>  codchi.secrets.env  Secrets / variables which must be set by each Codchi user. They will be\navailable in each shell session,   prefixed by   CODCHI_ , inside this code\nmachine, so don’t use this for super sensitive secrets.  Possible use cases:   GitHub / GitLab tokens for automatic git setup / repo cloning   Type: \nattribute set of (submodule)   Default:  { }   Example:   {\n      # Will be available as $CODCHI_GITLAB_TOKEN\n      GITLAB_TOKEN = {\n        description = ''\n          Access token with read_api, read_repository & write_repository scopes. \n          Can be created here: \u003Chttps://gitlab.example.com/-/user_settings/personal_access_tokens>. \n          Syntax: `oauth2:glpat-XXXXXXXXXXXXXXXXXXXX`.\n        '';\n      };\n    }\n   Declared by:    \u003Ccodchi/nix/nixos/driver/secrets.nix>  codchi.secrets.env.\u003Cname>.description  A short text describing what this secret is used for and how it should be obtained.\nThis will be shown to the user during   codchi rebuild .   Type: \nstrings concatenated with “\\n”   Declared by:    \u003Ccodchi/nix/nixos/driver/secrets.nix>  codchi.secrets.env.\u003Cname>.name  Name of this environment variable. Will be prefixed by   CODCHI_ .   Type: \nstring matching the pattern ^[a-zA-Z0-9:_\\.-]*$   Default:  \"‹name›\"   Declared by:    \u003Ccodchi/nix/nixos/driver/secrets.nix>  programs.java.packages  List of JDKs which should be symlinked to ~/.jdks (for IDEs lik IntelliJ).   Type: \nattribute set of package   Default:  { }   Example:   {\n  openjdk19 = pkgs.jdk19;\n}\n   Declared by:    \u003Ccodchi/nix/nixos/modules/java.nix>",{"id":338,"path":339,"dir":340,"title":341,"description":7,"keywords":342,"body":347},"content:4.contrib:contributing.md","/contrib/contributing","contrib","Contribution Guidelines",[343,344,345,346],"Workflow","Commits","Changelog","Release","  Contribution Guidelines  Workflow  New features (todo)     PR per feature (try to limit changes in a single PR)    Code Review    Build & Test in CI  New release   push tag to automatically create a pre-release  automatic tests run in CI (todo: linux tests)  do manual tests (todo: test checklist)  update changelog & release description (only full release)\n=> post changes to discourse  Commits  Use   conventional commits :   feat: for new features  fix: for bug fixes  docs: for documentation updates  refactor: for code refactoring  test: for test-related changes  chore: for maintenance tasks  Changelog   List all commits since the last relase grouped by the commit type (Feature, Bug Fix...)  Release  Include the changelog since the last   full  release",{"id":349,"path":350,"dir":340,"title":351,"description":352,"keywords":353,"body":359},"content:4.contrib:internals.md","/contrib/internals","Internals","This page describes the internals of Codchi. For an overview of what Codchi is read What is Codchi?",[230,354,355,356,357,358],"Capabilities","Drivers","Codchi Modules","Guidelines","Footnotes","  Internals  This page describes the internals of Codchi. For an overview of what Codchi is read   What is Codchi?  Overview  Technically Codchi is just a \"driver\" for any NixOS module, such as:     { \n   }\n  That is just an empty NixOS module. To build this into a bootable machine without Codchi, you need to provide the hardware configuration (e.g. file system layout, boot loader, kernel, kernel module & options, desktop environment, ...). This can vary a lot from machine to machine, although virtual machines alleviate some of this.  With Codchi, however, the empty module above is a buildable machine configuration on Windows 10 & 11 and Linux:     codchi   init   empty-machine\n   codchi   exec   empty-machine   --   uname   -a\n   >   Linux nixos 6.6.32   #1-NixOS SMP PREEMPT_DYNAMIC Sat May 25 14:22:56 UTC 2024 x86_64 GNU/Linux\n  This works because Codchi provides the hardware configuration, the drivers (i.e. WSL, LXD and so on), as well as host integration such as GUI and sound support, file system sharing between code machine and host, and much more.  The goal is to provide an easy to use NixOS driver for different platforms (currently Windows & Linux), where everything hardware related just works.  Capabilities  These are the capabilities provided by Codchi. Every new driver must at least fully implement the \"must\" items.     Category  Capability  Must / Should  Windows + WSL  Linux + LXD    Architecture  Each code machine on a host uses a shared store accessible via   nix-daemon  Must  ✅  ✅   Architecture  The file system of each code machine on a host can be accessed by the store for local NixOS configuration  Must  ✅  ✅   Run full NixOS  SystemD working properly  Must  ✅  ✅   Run full NixOS  Proper login shell, i.e.   codchi exec  creates a proper login shell with   $DISPLAY  set.  This is essential for the environment variables to be set correctly and for everything to start up correctly, including XDG autostart entries  Must  ✅  ❔   Host Integration  GUI & Sound:   codchi exec \u003CMACHINE_NAME> -- nix run nixpkgs#xorg.xeyes  must open xeyes on the host's desktop. X11 and wayland apps (with sound) must work.  Must  ✅  ❔   Host Integration  Tray icon: Codchi must be controllable through a tray icon on the host.  Must  ✅  ✅   Host Integration  Shortcuts to each program in each code machine must be visible in the host's start menu, such that GUI and terminal applications can be started with a single click.  Must  ✅  ✅   Host Integration  Terminal: Codchi must be integrated with the host's terminal, such that a terminal with a shell into each code machine can be opened from the codchi tray.  Must  ✅  ✅   Host Integration  Secrets: A code machine can define secrets, which the codchi driver must store (preferably encrypted) on the host and provide it on code machine start.  Must  ✅  ✅   Host Integration  File system sharing: The file system of each code machine should be accessible from the host, e.g. as with WSL.  Should  ✅  🚧 (Generally works through LXD, but UX can be improved)   Host Integration  GPU: If the host has a GPU driver installed, it should be usable from within a code machine.  Should  ❔  ❔   Host Integration  USB: USBs plugged into the host should be accessible from within a code machine.  Should  📝  📝   Host Integration  SSL certificates: The hosts trust chain should be used inside a code machine, so that self signed certificates work (often used in enterprises).  Should  📝  📝   Legend   ✅ = Fully implemented and tested  ❔ = Implemented, but untestet / buggy  🚧 = WIP  📝 = Planned  ❌ = Not implemented  Drivers  A Codchi driver has three parts:    The host driver:  This is a part of the Codchi executable that runs natively on the host and interfaces between generic code, the operating system and the virtualization software. Codchi's configuration and machine data files also reside on the host and must be shared with   codchistore  and each code machine. Repository:   codchi ,   codchiw   The Store Driver:  The   codchistore  is a minimal container in which the shared store resides and machines are built. This is where   nix-daemon  runs.   codchistore  must share the   /nix  directory with each code machine via a bind mount. Repository:   nix/container/store   The Machine Driver:  The Codchi machine driver is just a NixOS module that acts as a bridge between a hardware agnostic NixOS module and the host's virtualization software (Windows: WSL, Linux: LXD). It must make the file system of the code machine available to   codchistore  in order to allow local NixOS configuration. The WSL part is heavily inspired by   NixOS-WSL . Repository:   nix/nixos/driver    Note    One thing to note is that since a code machine doesn't have its own store, it can only run if   codchistore  is also running, and should therefore only be started by Codchi.  WSL    SystemD:  WSL natively supports SystemD.   GUI:  Windows natively supports GUI applications within WSL with WSLg using a mixture of Wayland and RDP. Unfortunately, because of the latter, this doesn't really provide a native experience for Linux GUI applications.   Therefore, by default,   VcXsrv , a native Windows X server, is included and enabled in codchi. It can be disabled in   configuration .   1   Sound:  WSLg provides a PulseAudio server by default which works well enough.   File sharing:  Files are shared accross WSL instances via bind mounts in   /mnt/wsl/codchi .   Environment variables, secrets:  Shared via   $env:WSLENV  and a file which is written by the host driver to   \\\\wsl$\\codchi-*\\... .   Shortcuts:  Although WSL creates shortcuts itself, they only work if the code machine is already running. Therefore they are disabled and rather created by codchi itself so we can ensure that   codchistore  is running.   Terminal integration:    https://learn.microsoft.com/en-us/windows/terminal/json-fragment-extensions   GPU:  WSL provides access to the GPU installed on the host via dynamic libraries and executables. Since a code machine is a NixOS system some LD hacks are neccessary.   Host Integration:  The default applications inside each code machine are configured such that files or webpages open in the default Windows browser    Issues with WSL    In the Windows tradition, WSL can sometimes fail for no apparent reason. For example, a Codchi command might fail, only to work when the same command is issued again. More work is needed in this area to catch all WSL hickups.  LXD    SystemD:  LXD doesn't care about the init system.   GUI:  X11 and wayland sockets are shared via bind mounts. Also   .Xauthority  is copied into each machine.   Sound:  PulseAudio / PipeWire sockets are shared.   File sharing:  All files reside on the host and are bind-mounted into   codchistore  and each machine.   Environment variables, secrets:  Shared via   lxc exec --env  and a file which is copied into the machine.   Shortcuts:  Desktop entries and menus are generated in the corresponding XDG directories.  VM Export    Planned    Integration with   nixos-generators  is planned to allow exporting a code machine to any / some VM format(s).  Codchi Modules  Codchi also provides its own set of [NixOS Options](../3.config/99.Codchi specific NixOS Options.md) in order to provide   Codchi-specific options (  codchi.secrets ,   codchi.welcome )  options to easy the creation of a development environment (  codchi.enableRecommendedConfig ,   codchi.docker ).  Repository:   nix/nixos/modules  Guidelines  These are the general design and contribution guidelines for Codchi. The goal is to make Codchi / NixOS easy to use and enjoyable while reducing the maintanence burden.    Reliable & Reproducible:  The native Codchi executable,   codchistore  and Codchi's NixOS configuration must be reliable. Quality of life features such as secrets must not affect the reproducibility of NixOS accross different hosts.   Fast   Easy to Use:   Features should be kept to a minimum.  Codchi should feel familiar (  git clone ,   docker exec ).   Building on Standards (NixOS modules):  No custom configuration format / vendor lock-in.   Simplicity:   Fewer but better features.  Simple design without a central Codchi-daemon.   Footnotes   Currently there are some security concerns in the GitHub repo of VcXsrv which is why it isn't included in Codchi by default anymore. But, if installed manually, it can still be used by Codchi (see   config ).   ↩  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":361,"path":362,"dir":340,"title":363,"description":7,"keywords":364,"body":365},"content:4.contrib:roadmap.md","/contrib/roadmap","Roadmap",[],"  Roadmap   Bugs     shortcuts / terminal fragments win\n   update path on every update => autostart codchi tray => run \"migration\"  Future   Announcement Post (Discourse, Reddit)  Features       codchi status  on windows is slow\n=> move wsl status checking / store container starting to scheduled / time based task      codchi recover  => fs tar export      codchi debug  => machine / store debug shell      codchi export {vmware,virtualbox,qemu,hyperv} \n=> export machine to VM image\n=> backup / migrating away    (  codchi state export ) => creating a base fs for files like IJ / eclipse config    (codchi daemon inside each code machine)\n   current bash solution too fragile\n=> Does init (secret / config fetching, log reporting)    (Custom certs auto adding)\n   => how to handle inside code machines?    (Linux Wayland support)    Shortcuts\n   Config option  tray icon  ip kopieren  open questions:   WSL\n   what happens if store stops and machines runs?  how to handle network reset (VcXsrv)?\n=> wslg as default?",1752254335903]